<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>地鐵留言 App - Pro 錄製版</title>
    <style>
        body, html { margin: 0; padding: 0; height: 100%; background: #000; overflow: hidden; font-family: sans-serif; }
        .app-container { position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; }
        .viewport { position: relative; flex: 1; background: #111; overflow: hidden; }
        video#v { width: 100%; height: 100%; object-fit: cover; }
        
        /* 預覽用的文字層 */
        #drawingCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; mix-blend-mode: multiply; }

        /* NHK 風格結尾 */
        #kuo-end {
            position: absolute; bottom: 80px; right: 20px; z-index: 999;
            color: white; opacity: 0; transition: opacity 0.5s; pointer-events: none;
            display: flex; align-items: flex-end; gap: 8px; font-family: serif;
        }
        .nhk-logo { border: 2px solid white; padding: 2px 8px; font-size: 20px; font-weight: 900; }
        .nhk-final { font-size: 40px; font-weight: bold; line-height: 1; }

        .ui-bar { background: #1a1a1a; padding: 15px; display: flex; flex-direction: column; gap: 10px; z-index: 200; }
        .row { display: flex; gap: 8px; }
        input { flex: 1; background: #333; border: 1px solid #444; color: #fff; padding: 12px; border-radius: 8px; }
        button { flex: 1; padding: 12px; border-radius: 8px; border: none; font-weight: bold; cursor: pointer; }
        .rec-btn { background: #FF3B30; color: #fff; }
    </style>
</head>
<body>

<div class="app-container">
    <div class="viewport" id="stage">
        <video id="v" src="Train.mov" loop muted playsinline crossorigin="anonymous"></video>
        <canvas id="drawingCanvas"></canvas>
        
        <div id="kuo-end">
            <span class="nhk-final">終</span>
            <div style="display:flex; flex-direction:column; font-size:10px;">
                <span>制作・著作</span>
                <div class="nhk-logo">ＫＵＯ</div>
            </div>
        </div>
    </div>

    <div class="ui-bar">
        <div class="row">
            <input type="text" id="userInput" value="新年快樂/2026">
            <button onclick="App.play()">預覽</button>
            <button class="rec-btn" id="recBtn" onclick="App.startCapture()">錄製影片</button>
        </div>
    </div>
</div>

<script>
const App = {
    // 座標點與時間設定 (時間已延後 0.1s)
    pts: [{x: 0.02, y: 0.38}, {x: 0.98, y: 0.26}, {x: 0.95, y: 0.74}, {x: 0.01, y: 0.55}],
    timing: { start: 2.45, end: 3.73, showEnd: 4.8 }, 
    
    init: function() {
        this.v = document.getElementById('v');
        this.canvas = document.getElementById('drawingCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.input = document.getElementById('userInput');
        
        window.addEventListener('resize', () => this.resize());
        this.resize();
        this.animate();
    },

    resize: function() {
        this.canvas.width = this.v.clientWidth;
        this.canvas.height = this.v.clientHeight;
    },

    play: function() {
        this.v.currentTime = 0;
        this.v.play();
    },

    // 核心渲染邏輯：支援自動分行與透視變換 [cite: 2025-12-28]
    drawText: function(targetCtx, w, h, isExport = false) {
        const text = this.input.value;
        const cur = this.v.currentTime;
        
        if (cur < this.timing.start) return;

        // 1. 離屏排版文字
        const temp = document.createElement('canvas');
        temp.width = 1000; temp.height = 400;
        const tCtx = temp.getContext('2d');
        
        let lines = text.includes('/') ? text.split('/') : (text.length > 5 ? [text.slice(0, Math.ceil(text.length/2)), text.slice(Math.ceil(text.length/2))] : [text]);
        let fontSize = lines.length > 1 ? 140 : 220;
        
        tCtx.fillStyle = "red";
        tCtx.textAlign = "center";
        tCtx.textBaseline = "middle";
        tCtx.font = `900 ${fontSize}px sans-serif`;

        lines.forEach((line, i) => {
            const y = 200 + (i - (lines.length-1)/2) * (fontSize * 1.1);
            tCtx.fillText(line, 500, y);
        });

        // 2. 準備透視投影座標
        const p = this.pts.map(pt => ({ x: pt.x * w, y: pt.y * h }));
        
        // 3. 計算揭開進度 (遮罩)
        const prog = Math.min(1, (cur - this.timing.start) / (this.timing.end - this.timing.start));

        targetCtx.save();
        // 套用由右往左的遮罩
        targetCtx.beginPath();
        targetCtx.rect(w * (1 - prog), 0, w, h);
        targetCtx.clip();

        // 4. 繪製文字 (這裡使用範例中的縮放對位法，確保錄影跟預覽一致) [cite: 2025-12-28]
        const cX = (p[0].x + p[1].x + p[2].x + p[3].x) / 4;
        const cY = (p[0].y + p[1].y + p[2].y + p[3].y) / 4;
        const angle = Math.atan2(p[1].y - p[0].y, p[1].x - p[0].x);
        const bW = Math.sqrt(Math.pow(p[1].x - p[0].x, 2) + Math.pow(p[1].y - p[0].y, 2));

        targetCtx.translate(cX, cY);
        targetCtx.rotate(angle);
        const scale = bW / 1000;
        targetCtx.scale(scale, scale);
        targetCtx.globalAlpha = 0.9;
        targetCtx.drawImage(temp, -500, -200);
        targetCtx.restore();
    },

    animate: function() {
        const cur = this.v.currentTime;
        document.getElementById('kuo-end').style.opacity = (cur >= this.timing.showEnd) ? '1' : '0';
        
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.drawText(this.ctx, this.canvas.width, this.canvas.height);
        
        requestAnimationFrame(() => this.animate());
    },

    // 錄製功能：參考您提供的結構優化 [cite: 2025-12-19, 2025-12-28]
    startCapture: async function() {
        const btn = document.getElementById('recBtn');
        btn.innerText = "錄製中..."; btn.disabled = true;

        const exportCanvas = document.createElement('canvas');
        // 強制鎖定直式高畫質
        exportCanvas.width = 720; exportCanvas.height = 1280;
        const eCtx = exportCanvas.getContext('2d');
        
        const stream = exportCanvas.captureStream(30);
        const recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9', bitsPerSecond: 10000000 });
        const chunks = [];

        recorder.ondataavailable = e => chunks.push(e.data);
        recorder.onstop = () => {
            const blob = new Blob(chunks, { type: 'video/webm' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob); a.download = `Train_Message.webm`; a.click();
            btn.innerText = "錄製影片"; btn.disabled = false;
        };

        this.v.currentTime = 0;
        await this.v.play();
        recorder.start();

        const renderLoop = () => {
            if (recorder.state === "recording") {
                // 畫背景 (直式 cover)
                eCtx.drawImage(this.v, 0, 0, exportCanvas.width, exportCanvas.height);
                // 畫文字 (同步 3D 效果)
                this.drawText(eCtx, exportCanvas.width, exportCanvas.height, true);
                
                // 畫結尾浮水印
                if (this.v.currentTime >= this.timing.showEnd) {
                    this.drawWatermark(eCtx, exportCanvas.width, exportCanvas.height);
                }
                
                if (this.v.ended) recorder.stop();
                else requestAnimationFrame(renderLoop);
            }
        };
        renderLoop();
    },

    drawWatermark: function(ctx, w, h) {
        ctx.save();
        ctx.fillStyle = "white";
        ctx.shadowBlur = 10; ctx.shadowColor = "black";
        ctx.font = "bold 48px serif"; ctx.fillText("終", w - 180, h - 100);
        ctx.font = "bold 13px sans-serif"; ctx.fillText("制作・著作", w - 120, h - 125);
        ctx.lineWidth = 2; ctx.strokeStyle = "white"; ctx.strokeRect(w - 120, h - 115, 80, 30);
        ctx.font = "bold 20px sans-serif"; ctx.fillText("ＫＵＯ", w - 110, h - 92);
        ctx.restore();
    }
};

window.onload = () => App.init();
</script>
</body>
</html>
