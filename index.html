<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>åœ°éµ 3D - å¯¦æ™‚é¡åƒéŒ„è£½ç‰ˆ</title>
    <style>
        body, html { margin: 0; padding: 0; height: 100%; background: #000; overflow: hidden; font-family: sans-serif; }
        .app-container { position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; }
        
        /* é è¦½å®¹å™¨ï¼šéŒ„å½±æœƒå®Œå…¨è¤‡è£½é€™è£¡çš„å…§å®¹ */
        .viewport { position: relative; flex: 1; background: #000; overflow: hidden; display: flex; align-items: center; justify-content: center; }
        
        video#v { width: 100%; height: 100%; object-fit: cover; z-index: 1; }
        
        #canvas-text { 
            position: absolute; top: 0; left: 0; width: 1800px; height: 800px; 
            transform-origin: 0 0; z-index: 2; pointer-events: none;
            clip-path: inset(0 0 0 100%);
        }
        
        #kuo-logo { 
            position: absolute; bottom: 20px; right: 20px; width: 100px; z-index: 99; 
            opacity: 0; transition: opacity 0.5s; pointer-events: none;
        }

        .ui-bar { background: rgba(0,0,0,0.9); padding: 15px; display: flex; flex-direction: column; gap: 10px; border-top: 1px solid #333; padding-bottom: env(safe-area-inset-bottom); }
        .row { display: flex; gap: 10px; align-items: center; justify-content: center; }
        input[type="text"] { flex: 1; background: #222; border: 1px solid #444; color: #fff; padding: 12px; border-radius: 8px; font-size: 16px; }
        
        /* éŒ„è£½æŒ‰éˆ•æ¨£å¼ */
        .rec-btn { width: 60px; height: 60px; border: 4px solid #fff; background: #ff0000; border-radius: 50%; cursor: pointer; transition: transform 0.2s; }
        .rec-btn:active { transform: scale(0.9); }
        #stop-hint { position: fixed; top: 40px; left: 50%; transform: translateX(-50%); background: #ff0000; color: white; padding: 8px 20px; border-radius: 20px; font-weight: bold; display: none; z-index: 1000; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }
    </style>
</head>
<body>

<div id="stop-hint">â— æ­£åœ¨éŒ„è£½ä¸­...æ’­å®Œè‡ªå‹•çµæŸ</div>

<div class="app-container">
    <div class="viewport" id="capture-zone">
        <video id="v" src="Train.mov" loop muted playsinline crossorigin="anonymous"></video>
        <canvas id="text-source" style="display:none;"></canvas>
        <img id="canvas-text">
        <img id="kuo-logo" src="IMG_6604.png">
    </div>

    <div class="ui-bar">
        <div class="row">
            <input type="text" id="userInput" placeholder="è¼¸å…¥æ–°å¹´å¿«æ¨‚..." oninput="App.renderText()">
            <input type="color" id="textColor" value="#ffffff" oninput="App.renderText()">
        </div>
        <div class="row">
            <div class="rec-btn" id="recTrigger" onclick="App.startRecording()"></div>
        </div>
    </div>
</div>

<script>
const App = {
    // åº§æ¨™å›ºå®šç™¾åˆ†æ¯” (åŸºæ–¼é è¦½å€åŸŸ)
    pts: [{x: 0.08, y: 0.35}, {x: 0.94, y: 0.22}, {x: 0.94, y: 0.78}, {x: 0.08, y: 0.58}],
    timing: { start: 2.55, end: 3.83, logoStart: 3.8, hide: 5.35, stop: 5.8 },
    isRecording: false,

    init: function() {
        this.v = document.getElementById('v');
        this.img = document.getElementById('canvas-text');
        this.txtCvs = document.getElementById('text-source');
        this.logo = document.getElementById('kuo-logo');
        this.zone = document.getElementById('capture-zone');
        this.ctx = this.txtCvs.getContext('2d');
        
        window.addEventListener('resize', () => this.updateWarp());
        this.updateWarp();
        this.renderText();
        this.animate();
    },

    updateWarp: function() {
        const r = this.zone.getBoundingClientRect();
        const p = this.pts.map(pt => ({ x: pt.x * r.width, y: pt.y * r.height }));
        const m = this.calcMatrix(0,0, 1800,0, 1800,800, 0,800, p[0].x, p[0].y, p[1].x, p[1].y, p[2].x, p[2].y, p[3].x, p[3].y);
        this.img.style.transform = `matrix3d(${m.join(',')})`;
    },

    renderText: function() {
        this.txtCvs.width = 1800; this.txtCvs.height = 800;
        const txt = document.getElementById('userInput').value || "ç™½å…­ç¥å¤§å®¶æ–°å¹´å¿«æ¨‚";
        this.ctx.clearRect(0,0,1800,800);
        this.ctx.save();
        this.ctx.translate(1750, 400); this.ctx.textAlign = 'right'; this.ctx.textBaseline = 'middle';
        this.ctx.fillStyle = document.getElementById('textColor').value;
        this.ctx.font = '900 300px sans-serif';
        this.ctx.scale(0.85, 2.0); // æ¨¡æ“¬é€è¦–å£“æ‰æ„Ÿ
        this.ctx.fillText(txt, 0, 0);
        this.ctx.restore();
        this.img.src = this.txtCvs.toDataURL();
    },

    animate: function() {
        const t = this.v.currentTime;
        const prog = Math.max(0, Math.min(1, (t - this.timing.start) / (this.timing.end - this.timing.start)));
        this.img.style.clipPath = (t < this.timing.start || t >= this.timing.hide) ? 'inset(0 0 0 100%)' : `inset(0 0 0 ${100 - prog*100}%)`;
        this.logo.style.opacity = (t >= this.timing.logoStart && t < 5.8) ? '1' : '0';
        if(!this.isRecording) requestAnimationFrame(() => this.animate());
    },

    // ğŸ”´ é—œéµéŒ„è£½é‚è¼¯ï¼šç›´æ¥æŠ“å– DOM å…ƒç´ çš„å¯¦æ™‚æ¸²æŸ“
    startRecording: function() {
        if(this.isRecording) return;
        this.isRecording = true;
        document.getElementById('stop-hint').style.display = 'block';
        
        const dpr = window.devicePixelRatio || 1;
        const outCanvas = document.createElement('canvas');
        outCanvas.width = this.zone.clientWidth * dpr;
        outCanvas.height = this.zone.clientHeight * dpr;
        const outCtx = outCanvas.getContext('2d');

        const stream = outCanvas.captureStream(30);
        this.recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
        this.chunks = [];
        this.recorder.ondataavailable = e => this.chunks.push(e.data);
        this.recorder.onstop = () => {
            const b = new Blob(this.chunks, { type: 'video/webm' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = 'Metro_Kuo_Method.webm'; a.click();
            document.getElementById('stop-hint').style.display = 'none';
            this.isRecording = false;
            this.v.loop = true;
            this.animate();
        };

        const drawFrame = () => {
            if(!this.isRecording) return;
            const t = this.v.currentTime;

            // 1. å…ˆç•«èƒŒæ™¯å½±ç‰‡
            outCtx.drawImage(this.v, 0, 0, outCanvas.width, outCanvas.height);

            // 2. æ ¸å¿ƒï¼šç›´æ¥æŠ“å–æ–‡å­—æ¨™ç±¤çš„ã€Œç•¶å‰è¨ˆç®—å¾Œçš„ä½ç½®ã€ç•«ä¸Šå»
            const r = this.img.getBoundingClientRect();
            const zoneR = this.zone.getBoundingClientRect();
            
            if (t >= this.timing.start && t < this.timing.hide) {
                outCtx.save();
                // ä½¿ç”¨ matrix3d é€²è¡Œé¡åƒç¹ªè£½
                const m = this.matrixArr || this.calcMatrixForRec(outCanvas.width, outCanvas.height);
                outCtx.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);
                
                const prog = Math.max(0, Math.min(1, (t - this.timing.start) / (this.timing.end - this.timing.start)));
                const clipX = 1800 * (1 - prog);
                outCtx.drawImage(this.txtCvs, clipX, 0, 1800 - clipX, 800, clipX, 0, 1800 - clipX, 800);
                outCtx.restore();
            }

            // 3. ç•« Logo
            if (t >= this.timing.logoStart && t < 5.8) {
                const lSize = 100 * dpr;
                outCtx.drawImage(this.logo, outCanvas.width - lSize - 20*dpr, outCanvas.height - lSize - 20*dpr, lSize, lSize);
            }

            if (t >= this.timing.stop) {
                this.recorder.stop();
            } else {
                requestAnimationFrame(drawFrame);
            }
        };

        this.v.pause();
        this.v.currentTime = 0;
        this.v.loop = false;
        this.v.play().then(() => {
            this.recorder.start();
            drawFrame();
        });
    },

    calcMatrixForRec: function(w, h) {
        const p = this.pts.map(pt => ({ x: pt.x * w, y: pt.y * h }));
        return this.calcMatrix(0,0, 1800,0, 1800,800, 0,800, p[0].x, p[0].y, p[1].x, p[1].y, p[2].x, p[2].y, p[3].x, p[3].y);
    },

    calcMatrix: function(x1,y1,x2,y2,x3,y3,x4,y4,px1,py1,px2,py2,px3,py3,px4,py4) {
        const a = [[x1,y1,1,0,0,0,-px1*x1,-px1*y1],[0,0,0,x1,y1,1,-py1*x1,-py1*y1],[x2,y2,1,0,0,0,-px2*x2,-px2*y2],[0,0,0,x2,y2,1,-py2*x2,-py2*y2],[x3,y3,1,0,0,0,-px3*x3,-px3*y3],[0,0,0,x3,y3,1,-py3*x3,-py3*y3],[x4,y4,1,0,0,0,-px4*x4,-px4*y4],[0,0,0,x4,y4,1,-py4*x4,-py4*y4]];
        const b = [px1,py1,px2,py2,px3,py3,px4,py4];
        for(let i=0;i<8;i++){
            let m=i; for(let j=i+1;j<8;j++) if(Math.abs(a[j][i])>Math.abs(a[m][i])) m=j;
            [a[i],a[m]]=[a[m],a[i]]; [b[i],b[m]]=[b[m],b[i]];
            for(let j=i+1;j<8;j++){ let f=a[j][i]/a[i][i]; b[j]-=f*b[i]; for(let k=i;k<8;k++) a[j][k]-=f*a[i][k]; }
        }
        const x=new Array(8);
        for(let i=7;i>=0;i--){ let s=0; for(let j=i+1;j<8;j++) s+=a[i][j]*x[j]; x[i]=(b[i]-s)/a[i][i]; }
        return [x[0],x[3],0,x[6],x[1],x[4],0,x[7],0,0,1,0,x[2],x[5],0,1];
    }
};
window.onload = () => App.init();
</script>
</body>
</html>
